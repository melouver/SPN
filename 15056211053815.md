# 密码学原理课程实验报告
## 任务书
1. 原始SPN实现
2. 对上述算法进行线性分析、差分分析
3. 增强以上SPN的安全性
4. 对原始SPN进行随机性检测
5. 生成RSA算法的参数
6. 快速实现RSA(利用中国剩余定理、模重复平方法、蒙哥马利算法加速模幂的过程）
7. 结合RSA和增强后的SPN实现文件(或通信)的加密
8. 构造彩虹表破解的hash函数

### 1.原始SPN
对于书上的SPN，明文是16位，密文是16位，密钥是32位，轮数为5，密钥的分配是根据简单的移位实现的。以下将分别陈述。

S盒: 对于16位的输入，将其分为4组，每组4位，然后分别对每组进行S盒变换。通过查阅S盒(一个16个元素的数组),返回变换后的4位输出，最后将这四个4位的输出合并成16位的最终输出。
![](media/15056211053815/15056220453619.jpg)
P盒: 对于16位的输入，我们直接查表(一个16个元素的数组），进行对应的permutation，然后返回16位的结果.
![](media/15056211053815/15056221628746.jpg)
密钥生成:我们通过不断选取连续的16位，来获得需要的所有密钥。通过指针返回结果。
![](media/15056211053815/15056222120150.jpg)
SPN加密:实现书上的SPN加密算法，在每一轮，首先通过异或混入轮密钥，然后进行S盒、P盒变换，最后得到我们需要的结果。
SPN解密:逆向实现SPN的加密过程，只不过需要使用S盒的逆和P盒的逆。
通过测试多组数据验证加解密结果正确:
![](media/15056211053815/15056234541176.jpg)
可以看到x与x'是相等的，说明加解密成功。
### 2.线性攻击
通过一系列变换，我们可以使用线性分析的方法找出原密钥中的其中8位，从而加速我们解密原密钥的速度。
实现书上的线性攻击算法，可以统计出最大概率的子密钥，即是我们需要的8位子密钥。
![](media/15056211053815/15056238881466.jpg)
找到这8位子密钥后，我们通过暴力搜索的方法来查出剩下的24位密钥。
![](media/15056211053815/15056239325877.jpg)
只通过一对明密文不能唯一确定原密钥。因此我们需要不断尝试，排除不满足条件的密钥，然后剩下的唯一密钥就是我们需要的正确结果。
![](media/15056211053815/15056239979399.jpg)
对于线性分析的性能测试：
![](media/15056211053815/15056240894702.jpg)
可以看到结果正确，用时在1s左右。
### 2.2 差分分析
类似于线性分析，我们需要找出大约50-100对正确对，然后统计满足条件的分布，最终得到需要的子密钥。
![](media/15056211053815/15056242506959.jpg)
之后的暴力破解同线性分析。
差分分析性能测试:
![](media/15056211053815/15056243110054.jpg)
也在1s左右。
### 3.SPN增强
对于原始的SPN，其容易被攻破，因此我们需要增强其安全性，具体方法有:增大明密文位数，对轮密钥的分配随机化，增多轮数，使用被验证安全的S盒、P盒等方法。
我的增强手段:
将明密文都增加到64位，原始密钥64位，通过循环右移来生成64位的轮密钥，将轮数增加到12轮。
通过随机生成多组明文，加密再解密来确定算法的正确性。
![](media/15056211053815/15056307906202.jpg)
### 4. 对SPN进行随机性检测
通过cipher-block-chaining和PKCS7的padding，让SPN加密后的结果随机性更强，并且可以完美解密。
对于1M的数据，具体测试结果如下：
![](media/15056211053815/15056327632986.jpg)
### 5.RSA参数生成
对于RSA的参数生成，有几个关键点:
1. p q需要是大素数。具体来说，我选择首先在0-100随机一个数，然后加上2^1024，这样就得到1024位的大数，使用Miller-Rabin算法来进行素性检测，如果不是素数，就跳到下一个奇数继续检测，直到找到一个素数。
2. 算出phi(n)后，我们通过不断随机1-phi(n)之间的数，直到找到一个与phi(n)互质的数，这个数就是公钥。再求出b模phi(n)的逆，这样就得到私钥a。
3. 最后返回公钥(n,b),私钥(p,q,a)
![](media/15056211053815/15056332658109.jpg)
### 6.快速实现RSA
对于RSA算法来说，最核心的性能瓶颈在于幂运算和模运算。
使用中国剩余定理可以加速解密过程。首先使用私钥预计算出dp=amodp-1,dq=amodq-1,然后求出qmodp的逆，这样以后，在每次解密的时候，我们只需要进行小规模的幂运算即可得到解密结果。
![](media/15056211053815/15056337598518.jpg)
而蒙哥马利算法可用于加速加解密过程。蒙哥马利算法的核心思想就是对于求解x*y(modN)的快速实现。由于x*y比N大的多，如果用普通的除法取余，速度会非常慢。因此我们可以让x * y的结果加上N的某个倍数，这个结果整除蒙哥马利域内的R。这样就能快速进行除法运算，得到结果的蒙哥马利形式，再从蒙哥马利形式转换为我们需要的结果。(某个数x蒙哥马利形式为x*R(modN))。
蒙哥马利乘法会得出x*y*R的结果，然后基于蒙哥马利乘法，我们可以构造出蒙哥马利模幂，这个过程还会利用模重复平方的思想，简化求幂运算的过程。具体代码见mont.h
模重复平方实际上是先将指数进行二进制分解，然后依次累乘，每一步的数量级不太大，因此速度很快，最终也能得到正确的结果。

### 7.利用SPN进行文件加密
PKCS#7:
利用SPN进行文件加密。由于待加密的文件大小不定，而我的SPN加密单元为64位，即8个字节，因此需要对读入的最后一组明文进行padding。如果最后一组恰好为64位，则需要在加密完这组明文后，再加密0x0808080808080808这64位数据，存入加密文件中。如果最后一组少于64位，则我们需要使用字节填充，让它64位对齐。填充的数据为原明文组缺少的字节数目，比如缺少2个字节，就填充0x0202。填充好之后再进行加密，写入加密文件。
在解密的时候，我们可以明确知道加密文件一定是64位对齐的，因此可以放心解密，但在这个过程中一定要记录下读入的字节数目，即是加密文件的总大小。读完之后，我们需要检查最后一个明文字节的内容，因为它暗示了之前填充的数据长度，减去这个数据长度才是我们真正需要的明文。因此实际上我们需要精确控制写入解密文件的大小。
CBC:
Cipher-block-chaining可以让我们的加密文件随机性强很多。这需要我们使用一个随机的initialization vector来混入到加密过程，然后在解密的时候使用同样的IV。

## 心得:
通过这次课程设计，我对于密码学的初级理论有了进一步的认识，对于大数运算所存在的复杂性，以及与之相对应的密码体系安全性有了进一步的理解。从加密的理论到计算机的实现，到快速实现，需要理论与应用结合。但我深知密码学是十分深奥严谨的领域，仍需要不断学习与实践，才能全面领悟密码学的来龙去脉，将严谨的理论高效清晰快速地应用于实际系统中。



